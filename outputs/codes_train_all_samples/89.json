{"89": {"code": ["\n\n-----Output-----\n\n\n\n-----Input-----\n\nThe top line is the root of the tree.\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n BFS on a tree with a maximum depth of $n$\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n\n\n\n\n-----Input-----\n\n\n\ndecided by BFS\n\n-----Input-----\n\nThe main line\n\ng = Queue()\n\n-----Output-----\n\n\n-----Input-----\n\nHe lost a tree\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n BFS on a tree\n\n-----Input-----\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n\n\n\n\n-----Input-----\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n-----Input-----\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n BFS on a tree with a maximum depth of a tree.\n\n-----Output-----\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n BFS on a tree which has no children.\n\n-----Output-----\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n BFS to find a tree\n\n-----Input-----\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n BFS on a tree which is not visited, so he decided to restore his tree.\n\n-----Input-----\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n\n\n-----Input-----\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ng", "\n\n-----Output-----\n BFS on a tree.\n\n-----Input-----\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ng =", "\n-----Output-----\n\n\n\n\n\n-----Input-----\n\n\ndecided by BFS on a tree which consists of two lists:\n\ng = Queue()\n\n-----Output-----\n\nThe first line:\n\ng = Queue()\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n\n\n\n\n\n\n\n-----Input-----\n\nHe decided to find a tree with multiple visiting orders\n\ng = Queue()\n\n-----Input-----\n\nThe tree has two examples\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n", "\n\n-----Output-----\n\n\n\n\n-----Input-----\n\n\n\n\ndecided by BFS\n\n-----Input-----\n\nHe decided to find a tree\n\n-----Input-----\n\ng = Queue()\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n\n\n-----Input-----\n\n\n\n\n\n-----Input-----\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n\n\n\n\n-----Output-----\n\n\n\n-----Input-----\n\n\n\n-----Input-----\n\nHe decided to find a tree which consisted of a list of vertices in a list of vertices in a list of order\n\ng = Queue()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n\n\n\n-----Output-----\n\n\n-----Input-----\n\nThe root of a tree is the root of a tree\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nq =", "\n\n-----Output-----\n\n\n-----Input-----\n\nMonocarp is started with some test cases\n\n-----Input-----\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n-----Output-----\n\n\n\n-----Input-----\n\nHe decided to find a tree with a maximum height of a tree.\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----Output-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Output-----\n\n\n\n\n\n-----Input-----\n\n\n\ndecide for a tree\n\n-----Output-----\n\nHe decided to find all tree\n\n-----Input-----\n\ng = Queue()\n\n-----Input-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----"], "prompt": "\nQUESTION:\nMonocarp had a tree which consisted of $n$ vertices and was rooted at vertex $1$. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processed\n\nq = Queue()\n\nq.put(1) # place the root at the end of the queue\n\nwhile not q.empty():\n\n    k = q.pop() # retrieve the first vertex from the queue\n\n    a.append(k) # append k to the end of the sequence in which vertices were visited\n\n    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order\n\n        q.put(y)\n\n\n\nMonocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array a from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed in ascending order.\n\nMonocarp knows that there are many trees (in the general case) with the same visiting order $a$, so he doesn't hope to restore his tree. Monocarp is okay with any tree that has minimum height.\n\nThe height of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex $1$ is $0$, since it's the root, and the depth of all root's children are $1$.\n\nHelp Monocarp to find any tree with given visiting order $a$ and minimum height.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$; $a_i \\neq a_j$; $a_1 = 1$)\u00a0\u2014 the order in which the vertices were visited by the BFS algorithm.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print the minimum possible height of a tree with the given visiting order $a$.\n\n\n-----Example-----\nInput\n3\n4\n1 4 3 2\n2\n1 2\n3\n1 2 3\n\nOutput\n3\n1\n1\n\n\n\n-----Note-----\n\nIn the first test case, there is only one tree with the given visiting order:  [Image] \n\nIn the second test case, there is only one tree with the given visiting order as well:  [Image] \n\nIn the third test case, an optimal tree with the given visiting order is shown below:  [Image]\nUse Standard Input format\nANSWER:\n"}}