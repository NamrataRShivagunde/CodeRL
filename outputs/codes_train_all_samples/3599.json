{"3599": {"code": ["\n\n\n\n\n\n\nf1(76,4) == 260\nf2(76,4) == 355\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n* `n` and `k` will always be a valid integer.\n* `f2` will always be an integer.\n*``", "\n\n\nfind_f1_eq_f2()\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\nf1(n,k) == 3\nf2(n,k) == 3\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(n,k) == 4\nf2(n,k) == 4\n\n\n", "\n\n\n\n\n\n\nn,k = 1023,6\nk = 2\n\n**Features**\n\n*\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n1(1,1) == 1,1,1\n```\n\n\n\n\n\n\nf1(4) == 4\nf2(4) == 4\n\n\n", "\n**Features**\n\n\nf1(n,k) == 0\nf2(n,k) == 9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**Features:**\n\n* `n` and `k` will always be positive integers\n* `k` will always be\n* `", "\n\n\nfind_f1(n,k) == 4\nfind_f2(n,k) == 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(1800,7) == 134\nf2(1800,7) == 1\n```\n\n\n\n* `f", "\n\n\nfind_f1_eq_f2(n,k) = 1\n\n\n\n\n\n\n\n\n\n\n\nf1(n,k) == 1\nf2(n,k) == 1\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(n,k) == 469\n\n\nf1(34", "\n\n\n\n\n\n\n\nf1(2,3,4) == 2351\nf2(2,5) == 4351\n\n**Examples**\n\n*\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nkata:\n\n* `k` = 4\n\n\n* `f", "\n\n\n\n\n\n\nf1(k)\nf2(k)\n\nf2(k)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**Features:**\n\n* `n` and `k` will always be positive integers\n\n* `n` and `k` will always be positive", "\n\n\n\n\n\n\nf1(2) == 5\nf2(2) == 6\nf2(2) == 7\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n* `n` and `k` will always be valid.\n* `k` will always be valid.\n\n* `f", "\n**Features:**\n\n\n\n\n\n\n\n\n\nn = 0\nk = 0\n\n\n\n\n\nf1(2,3) == 2\nf2(2,3) == 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf2(1,2) == 1186\n\n\n\n* `n` is a forg", "\n\n\n\n\n\n\n\nfind_f1_eq_f2(n,k) == 4606 # n <= k\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-k <= 0.000 # k >= 0.000\n```\n\n**Features:**\n\n* `n` and `k` will", "\n\n\nfind_f1_eq_f2(n,k)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**Features:**\n\n* `n` and `k` will always be positive integers\n* `f1` will always be positive integers\n* `f2`", "\n\n\n\n\n\n\n\n\n\n\n\nn = 0\nk = 0\n\n**Features:**\n\n* `n` and `k` will always be valid.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\nf1(n,k) == 4\nf2(n,k)\n", "\n**Features:**\n\n\n\n\n\n\n\nf1(1,2,3) == 1\nf2(1,3) == 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n1 <= n <= 87 <= k <= 7\n1 <= k <= 7\n\n```\n\n", "\n\n\nfind_f1_eq_f2(1,2,3) == 545\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(76,4) == 261 # the number `n` is forgiving number of order `4`.\nf2(76,4)\n\n**", "\n\n\nf2(n,k) = 1 # all digits less than k\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n* `f1` and `f2` will be the same\n* `f2` will be the same\n* `f1` and `f2", "\n\n\n\n\n\n\n\n\n\n\n\n678\n\nf1(5,7,9) == 678\nf2(5,7,9) == 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(342,6) == 3467\n\nf2(342,6)\n\n\n", "\n\n\nf1(n,k) = 4\n\nf2(n,k) = 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n* `n` will always be a positive integer, `k` will always be a positive integer\n* `k` will always be an integer\n\n*", "\n\n\nf1(80,8) == 460 # k = 1,2,3\n\n\n\n\n\n\n\n\n\n* `n` <= 1 <= k <= 5\n* `k` <= 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n* `n` and `k` will always be positive integers\n\n\n\n* `f1`", "\n\n\n\n\n\n\nf1(3,4) == 349\nf2(3,5) == 349\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf1(4) == 4\nf2(4) == 4\nf1(5) == 5\nf2(5) ==\n"], "prompt": "\nQUESTION:\nWe define the function `f1(n,k)`, as the least multiple of `n` that has all its digits less than `k`. \n\nWe define the function `f2(n,k)`, as the least multiple of `n` that has all the digits that are less than `k`.\n\nEach digit may occur more than once in both values of `f1(n,k)` and `f2(n,k)`.\n\nThe possible values for `n` and `k` according to these ranges for both functions `f1` and `f2` in this kata:\n``` \n1 <= n <= 1.000.000.000.000\n3 <= k <= 9\n``` \n\nFor example, let's see the value of both functions for `n = 71` and `k = 4`:\n``` \nf1(71,4) == 213 # all its digits less than 4\nf2(71,4) == 2130 # 0,1,2,3 all of them present \n```\nThe integer `76` is the first integer that has the same values of `f1` and `f2` for `k = 4`. \n```\nf1(76,4) = f2(76,4) = 10032\n```\nLet's call these kind of numbers, **forgiving numbers**. (Let's continue with the fashion of attributing personality traits to numbers and, of course, an unknown one)\nSo, `76` is the smallest forgiving number of order `4`.\nIn the same way, `485` is the smallest forgiving number of order `5`.\n\nCreate a function that given an integer `n` and the order `k`, will output the higher and closest forgiving number to `n` of order `k`.\n\nLet's see some examples:\n```\nfind_f1_eq_f2(500,5) == 547\nfind_f1_eq_f2(1600,6) == 1799\nfind_f1_eq_f2(14900,7) == 14996\n```\nIf the number `n` is a forgiving itself for a certain order `k`, the function will never output the same value, remember, closest and **higher** than `n`.\n\nFor example, `3456`, is a forgiving one of order `4`,\n```\nfind_f1_eq_f2(3456,4) == 3462\n```\n**Features of the tests:**\n\n* `n` and `k` will be always valid and positive integers.\n\n* A total of 8 fixed tests.\n\n* A total of 150 random tests in the ranges for `n` and `k` given above.\n\nI'll be waiting your awesome solution. :)\ndef find_f1_eq_f2(n,k):\n\t\nUse Call-Based format\nANSWER:\n"}}