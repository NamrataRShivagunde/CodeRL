{"4683": {"code": ["\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon):\n\n\n\n\niter_pi(0.001)\n\niter_pi(1):\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n1.318592653839794 \n\n\n\n\n\n\n3.14059", "\n\n\niter_pi(epsilon):\n\nUse Call-Based format\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   \n\n\n\n\n\n\n\n\n```\n\nThe aim of the kata is for the following iterations:\n\n\n\n\n\n", "\n\n\n\n \n\n\n\niter_pi(epsilon)\n\nReturn number :\n\nPI\n\nThe number : \n\niter_pi(epsilon):\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n``` \n\n# \t# References :", "iter_pi(epsilon):\n\n\n\n\n\n\n\n\n\n\nDo not use the function \"trunc10Dble\" (via math::trunc10) \n\nThis is a call-Based function. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.2\n\n3.2.2\n\n\n\n\n\n2.", "\n\n\n\n\n\n\niter_pi(epsilon):\n\niteration = 0\niter_pi(epsilon)\n\niteration = 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# I18N: \n\n# Fenny\n#\n\n# Aim of the kata \n\n#\n\n\n#", "\n```\n\n\n\n \n\nThe following function is used to calculate the iterative procedure : \n\niter_pi(epsilon):\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon):\n\n1 - 1/2 + 1/3\n\n3\n\n\n\n1006", "\n\n\n \n \n\n\n\n\niter_pi(epsilon):\n\niter_pi(0.001)\n\niter_pi(1.0)\n\niter_pi(3.0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n## Example", "\n\n\niter_pi(epsilon):\n\n \n\n\n\n\n\n\n\nThis is a function : \n\niter_pi(epsilon)\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n--- \n\n\n\n\n```\n\nThe aim of", "iter_pi(epsilon):\n\t\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n## Example :\n\n# Leibniz 1646\u20131716\n\n\n\n# The", "iter_pi(epsilon):\n\n\n\n \n\n\n\n\n\n\n \n\niter_pi(0.001):\n\niter_pi(1.001)\n\niter_pi(1.001):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n\n\n#\n#\n\n# ---------\n#\n# \n# Which", "\n\n\n\n\n\n\niter_pi(epsilon):\n\niter_pi(0)\n\n```\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n2.3.5.2\n\n3.3.3.2.3\n\n\n\n\n# [2]\n", "\n\n\n\n\n \n\n\n\n\n\niter_pi(epsilon):\n\t\niter_pi(epsilon)\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n``` \n\n    We have a good example : \n\n   \n\n```\n\n\n\n\n\n\n\n\n\n\n\n``` \n", "\niter_pi(epsilon):\n\t\n\n\n\n\n\n\n\n\n\n\n \n\n\niter_pi(0.001) \n\niter_pi(1.001) \n\niter_pi(1.001)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# IEXIT\n\n\n\n\n\n## Tests\n\n", "\n\n\n\n\n\n\n\niter_pi(epsilon):\n\niter_pi(0.001)\n\n\n\n\n\n\n\n\n\n\niter_pi(0.001):\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\niter_pi(epsilon)\n\n\n\n\n##\n#     iter_pi", "iter_pi(epsilon):\n\n\n\n\n\n\n\n\n\niter_pi(epsilon):\n\n#\n\niter_pi(1)\n\n#\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n# Chances : \n\n0.001 = 1.0\n0.01 = 1\n\n#\n\n\n\n\n# The same is a", "iter_pi(epsilon):\n\n\n\n\n\n\n\n\n\n\niter_pi(0.001)\n\n\n\n\n\n\niter_pi(epsilon):\n\niter_pi(0.001)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "iter_pi(epsilon):\n\t\"\"\"\n\nUse Call-Based format\n\n\n\n\n\n\n\niter_pi(epsilon):\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.5e-5 \n\n3.140592653839794\n\n\n\n\n\n\n``` \n", "iter_pi(epsilon):\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(0.001)\niter_pi(1)\niter_pi(1)\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\nThis function calculates the number of iterations \n\n2.1.2.3.3\n\n\n\n\n", "\n\niter_pi(epsilon):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon):\n\niter_pi(epsilon)\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMath::PI = 5.0\n\n\n\n\n\n\n# Explanation:\n\n", "\niter_pi(epsilon)\n\n\n\n\nCall-Based format : \n\niter_pi(epsilon):\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(epsilon)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niter_pi(0.001)\n\n\n\n\n\n\n```"], "prompt": "\nQUESTION:\nThe aim of the kata is to try to show how difficult it can be to calculate decimals of an irrational number with a certain precision. We have chosen to get a few decimals of the number \"pi\" using\nthe following infinite series (Leibniz 1646\u20131716): \n\nPI / 4 = 1 - 1/3 + 1/5 - 1/7 + ... which gives an approximation of PI / 4.\n\nhttp://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n\nTo have a measure of the difficulty we will count how many iterations are needed to calculate PI with a given precision. \n\nThere are several ways to determine the precision of the calculus but to keep things easy we will calculate to within epsilon of your language Math::PI constant. In other words we will stop  the iterative process when the absolute value of the difference between our calculation and the Math::PI constant of the given language is less than epsilon.\n\nYour function returns an array or an arrayList or a string or a tuple depending on the language (See sample tests) where your approximation of PI has 10 decimals \n\nIn Haskell you can use the function \"trunc10Dble\" (see \"Your solution\"); in Clojure you can use the function \"round\" (see \"Your solution\");in OCaml or Rust the function \"rnd10\" (see \"Your solution\") in order to avoid discussions about the result.\n\nExample :\n```\nyour function calculates 1000 iterations and 3.140592653839794 but returns:\niter_pi(0.001) --> [1000, 3.1405926538]\n```\n\nUnfortunately, this series converges too slowly to be useful, \nas it takes over 300 terms to obtain a 2 decimal place precision. \nTo obtain 100 decimal places of PI, it was calculated that\none would need to use at least 10^50 terms of this expansion!\n\nAbout PI : http://www.geom.uiuc.edu/~huberty/math5337/groupe/expresspi.html\ndef iter_pi(epsilon):\n\t\nUse Call-Based format\nANSWER:\n"}}