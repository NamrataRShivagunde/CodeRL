{"3766": {"code": ["\n~~~if:java\nThis decomposition may not be used. \nif:java\n~if:java\n\n~~~if:java\n\n\n\n\n\n\n~~~if:java\n~~~if:java\n~\n\n\n\n\n\n\n\n\n\n\n\n~~~endif-not:java\n\n~~~endif\n\n\n\n\n\n~~~end", "\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n\n~\n\n\n~~~if:java\n~~~if:java\n~~~if:java\n\n\n\n\n\n\n\n\n\n\n\n~~~endif\n\n\n~~~endif\n\n\n[[2],[2]]", "\n\n\n\n\n\n~~~if-not:java\n\n\n~~~if:java\n~~~if:java\n\n~~~if:java\n[[],[]]` and  `[]`. \n\n~~~if:java\n\n\n\n\n\n\n\n\n\n~~~else-not:java\n\n~~~else:java\n\n\n[[2],[1]]", "\n\nif:java\n\nThis decomposition may not be used for all functions. \n\n~~~if:java\n\nThis decomposition may not be used for all functions. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n~~~if:java\n\n\n\n\n\n~~~else:java\n\n\n\n~~~else:java\n\n\n\n `[[1],[", "\n\nif-not:java\n\n~~~if-not:java\n\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n\n~~~if:java\n~~~if:java\n~~~\n\n\n\n\n\n\n\n\n\n\n\n~~~if:java\n~~\n\n\n[[2,2],[", "\n~~~else:java\n~~~else:java\n~~~else:java\n\n~~~else:java\n\n~~~else:java\n\n~~~else:java\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n~~~endif-not:java\n\n\n~~~endif-not:java\n\n\n `[[2],[2", "\n\nif-not:java\n\nA function **getPrimeFactorPotencies** wich return an array containing the prime factors to their respective powers. \n\nErrors: \n\n \n \n\n~\n\n\n\n~if:java\n\n\n\n\n\n\n\n\n\n\n\n\n~~~if-not:java\n\n~~\n\n `[[2],[1]]` and", "~~~if:java\nif-not:java\n~~~if:java\n~~~else:java\n~~~endif\n~~~endif\n~~~endif\n\n\n\n~~~endif\n~~~endif \n~endif \n\n\n\n\n\n\n\n\n\n\n\n\n\n~~~endif\n\n\n\n\n `[[2],[1]]", "  `getAllPrimeFactors(100)` returns `[1,2,3,5,3,5]`. \n\n\n\n\n~if:java\n\n\n\n~~~if:java\n~~~`\n\n\n\n\n\n\n\n\n\n~~~else\n\n~~~if-not:java\n\n\n\n\n\n~~~else:java\n\n`\n\n", "\n~~~if:java\n\n~~~if:java\n\n~~~if:java\n\n\n~~~if:java\n\n~~~if:java\n~~~if:java\n\n~~~if:java\n\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n~~~\n\n\n~~~end-not:java\n\n\n[[],[2", "\n\n~~~if:java\n\nThis function should return an array containing two arrays: one with prime factors, two with prime factors, two with prime factors, \n\n\n\n\n\n\n\n\n\n`\n\n\n\n\n\n\n\n\n\n\n\n~~~if-not:java\n\nYou have code a function **getAllPrimeFactors** \n\n\n\n[[2],[", "\n\n\n~~~if:java\nYou have code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing one array containing the two factors. \n\n\n\n\n\n\n\n\n\n\n`\n\n\n\n\n\n\n\n\n\n~~~end-not:java\n\n\n\n\n\n `[[2],[1]]` and `[[", "\n~~~\n\n\n~~~\n\n~~~else:java\n\n\n~~~if:java\n\n~~~else:java\n~\n\n~~~else:java\n\n\n~~~else:java\n\n~\n\n\n\n\n\n\n\n\n\n~~~endif\n\n\n\n~~~endif\n\n~~~endif\n\n\n[[2],[", "\n~~~if:java\nif:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~\n~~~if:java\n\n\n~if:java\n~ \n\n\n\n\n\n\n\n\n~~~if-not:java\n\n\n\n\n\n~~~if-not:java\n[[2],[", "\n~~~else:java\n~~~else:java\n~~~else:java\n\n\n~~~else:java\n\n~~~else:java\n\n\n\n~~~else:java\n\n~~~else:java\n\n\n\n\n\n\n\n\n\n\n~~~endif-not:java\n\n\n\n\n\n\n `[[1],[2]]` and `", "\n~~~if:java\nreturn `[2,2,5,2]` \n~if:java\n\n\n~~~\n\n~~~\n~~~\n\n~~~\n~~~if:java\n`\n\n\n\n~~~if:java\n\n\n\n\n\n\n\n\n~~~if-not:java\n~~~if:java\n\n\n[[2],", "\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n~~~endif\n\n\n\n\n\n[[2],[1]]`, `[[1", "\n~~~java\n\n~~~if:java\nYou have code a function **getAllPrimeFactors** wich take an integer as parameter \n\n~~~if:java\n\n\n\n\n\n\n\n\n`\n\n\n~~~\n\n~~~\n\n~~~\n\n\n\n\n\n\n~~~\n\n~~~\n\n\n `[[1],[2]]` and", "\n~~~if:java\n\n~~~if:java\n\n~~~if:java\n\n~~~if:java\n~~~if:java\n~~~if:java\n~~~if:java\n\n~~~if:java\n~~~\n\n\n\n\n\n\n\n\n\n~~~else:java\n\n\n\n\n\n `[[2],[1]]` and", " \n\n\n\n\n\nif-not:java\n\n\n~~~if:java\n\n~~~if:java\n~~~if:java\n\n~~~if:java\n[n, n] \n\n\n~~~if:java\n\n\n\n\n\n\n\n\n\n~~~endif\n\n~~~endif\n\n~~~endif\n\n\n[[1],"], "prompt": "\nQUESTION:\n~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)\ndef getAllPrimeFactors(n):\n\t\nUse Call-Based format\nANSWER:\n"}}