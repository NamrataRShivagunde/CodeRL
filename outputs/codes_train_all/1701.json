{"1701": {"code": ["\n\n\n\n\n\n\n\nThe Internal API\n-------------------\n\nThe Internal API\n-------------------\n\nThe CPU API\n-------------------\n\nThis time we're going writing a CPU class\n-------------------\n\n### Internal API\n\n### Internal API\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `pushr()` and `pop", "\n\n\n\nThe Instruction Set\n-------------------\n\nRegisters\n-------------------\n\nRegisters\n-------------------\n\nRegisters\n-------------------\n\nRegisters\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n the stack\n\n```python\npush", "\n\n\n\n\n\n\n\n\nThe Operators\n-------------------\n\nThe Operators\n\n```\n\npush [reg|int]\n\nPushes a value onto the stack\n\npop [reg|int]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n the two executions `push", "\n\n\n\n\n\n\n\n\nRegisters\n-------------------\n\nRegisters available through Java\n\nRegisters are all available in Python\n\nRegisters are set by the CPU API.\n\nRegisters are set by the CPU API.\n\nRegisters are set by Java.\n\nRegisters\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `push", "\n\n\nThe Operators\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n### Stack Operation\n\n-------------------\n\nThe Stack Operations\n-------------------\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\npush[reg|int]: Pushes a value of a register onto the stack.\n\n\n `push[", "\n\n### Stack Operations\n\n\n\n\n\n\n\n\n\n\nThe CPU API\n-------------------\n\nThe CPU API\n-------------------\n\nThe CPU API\n-------------------\n\nThe CPU API\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n the two executions `push", "\n\n\n\n\n### Stack Implementation\n------------------------------\n\n# Stack Implementation\n\n\n\n\n\n\n\n\n\nThe CPU Implementation\n-------------------\n\nThe CPU API\n-------------------\n\nThe CPU API\n-------------------\n\nThe CPU API\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n poprr()\n\nread", "\n\n\n\n\n\n\n\n\n\nThe CPU Operators\n---------------------------\n\nThe CPU Operations\n-------------------\n\n### Stack Operations\n\n```\n\nPushes a value onto the stack\n\npop [reg]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n popr() and `poprr", "\n\n\n\nThe Operators\n-------------------\n\nOperators\n-------------------\n\nOperators\n-------------------\n\nOperands\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\npush[reg|int]:\n the stack.\n```\n", "\n\n\n\n\n\n\n\n\n\nThe Stack Operations\n-------------------\n\nThe Stack Arithmetic Operations\n-------------------\n\nThe Stack Arithmetic Machine\n-------------------\n\nThe Stack Operations\n-------------------\n\nThe Stack Operations\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n stack and stack arithmetic machine", "\n\n\n\n### Stack Operations\n\n-------------------\n\nGeneral Operations\n\n```python\nread_reg(self, name)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n registers.\n\n```python\nread_reg", "\n\n\n\n\n\nThe Instruction Set\n-------------------\n\nThis time we're going writing a CPU API\n\n\n\n\n\n\n\nThe CPU API\n-------------------\n\nPython\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n the stack.\n\n```python\npush [reg|", "```\n\n### Stack Operation\n\n-------------------\n\n\n\nThe Stack Operation Set\n-------------------\n\nThe Stack Operation Set\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Instruction Set\n-------------------\n\n\n\n\n\n\n a, b, c, d, and", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npush [reg|int]: Pushes a value of the given register to the stack.\npush [reg|int]: Pushes a value of the given register to the stack.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n [reg]\n\n### Internal\n\n----------------", "\n\n\n\n\n\nThe Instruction Set\n-------------------\n\nThe Instruction Set\n-------------------\n\nThis time we're going writing a CPU API\n\n### Stack Operations\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `pop` and `", "\n\n\n\nThe Stack Operations\n-------------------\n\nThe Stack Operations\n-------------------\n\nThe Stack Operations\n-------------------\n\nRegisters\n-------------------\n\nRegisters\n-------------------\n\nRegisters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `pop` and", "```\n\n\n\n\nThe Operators\n----------------\n\n\nOperands\n-------------------\n\n\nOperands\n-------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npush [reg|int]: Pops a value onto the stack.\n\n\n `push", "\n```\n\n\n\n\n\n\n\n\n\n\nThe Operators\n-------------------\n\nRegisters\n-----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Stack Operations\n-------------------\n\nRegisters\n-------------------\n\nRegisters in reverse order\n\nPushes [reg]\n\n\n\n\n\n\n the stack.\n```", "\n\n\n\n\n\n\n\n\n\n\nRegisters\n-------------------\n\nRegisters that are used to interact with the CPU class\n\n```python\n\npush [reg|int]: Pushes a register to the stack, in order.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `pushr()`", "\n\n\n\n\n\n\n\n\n\n\n\nThe CPU Operation\n-------------------\n\n\n\n\n### Stack Operations\n-------------------\n\nGeneral Operations\n\n```python\nreadReg()\nwriteReg()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n `popr()` and `poprr()`"], "prompt": "\nQUESTION:\nThe Stack Arithmetic Machine\n---------------------------\n\nThis time we're going to be writing a stack arithmetic machine, and we're going to call it Sam. Essentially, Sam is a very small virtual machine, with a simple intruction set, four general registers, and a stack. We've already given a CPU class, which gives you read and write access to registers and the stack, through `readReg()` and `writeReg()`, and `popStack()` and `writeStack()` respectively. All instructions on Sam are 32-bit (Java int), and either interact with the stack, or one of the 4 registers; `a`, `b`, `c`, or `d`.\n\nThe CPU API\n-----------\n\nThe CPU instructions available through the CPU class, with a bit more detail:\n\n```python\nread_reg(self, name): Returns the value of the named register.\nwrite_reg(self, name, value): Stores the value into the given register.\n\npop_stack(self): Pops the top element of the stack, returning the value.\nwrite_stack(self, value): Pushes an element onto the stack.\n```\n\nNote that the registers have a default value of `0` and  that the sStack is printable (if needed).\n\n\n\nThe Instruction Set\n-------------------\n\nInstructions for same are done in assembly style, and are passed one by one into the `Exec|exec|execute` function (depending on your language). Each instruction begins with the name of the operation, and is optionally followed by either one or two operands. The operands are marked in the table below by either `[reg]`, which accepts a register name, or `[reg|int]` which accepts either a register, or an immediate integer value.\n\n### Stack Operations\n\n```\npush [reg|int]: Pushes a register [reg] or an immediate value [int] to the stack.\n\npop: Pops a value of the stack, discarding the value.\n\npop [reg]: Pops a value of the stack, into the given register [reg].\n\npushr: Pushes the general registers onto the stack, in order. (a, b, c, d)\n\npushrr: Pushes the general registers onto the stack, in reverse order. (d, c, b, a)\n\npopr: Pops values off the stack, and loads them into the general registers, in order so that the two executions `pushr()`  and `popr()` would leave the registers unchanged.\n\npoprr: Pops values off the stack, and loads them into the general registers, in order so that the two executions `pushr()`  and `poprr()` would invert the values of the registers from left to right.\n```\n\n### Misc Operations\n\n```\nmov [reg|int], [reg2]: Stores the value from [reg|int] into the register [reg2].\n```\n\n### Arithmetic Operations\n\n```\nadd [reg|int]: Pops [reg|int] arguments off the stack, storing the sum in register a.\n\nsub [reg|int]: Pops [reg|int] arguments off the stack, storing the difference in register a.\n\nmul [reg|int]: Pops [reg|int] arguments off the stack, storing the product in register a.\n\ndiv [reg|int]: Pops [reg|int] arguments off the stack, storing the quotient in register a.\n\nand [reg|int]: Pops [reg|int] arguments off the stack, performing a bit-and operation, and storing the result in register a.\n\nor [reg|int] : Pops [reg|int] arguments off the stack, performing a bit-or operation, and storing the result in register a.\n\nxor [reg|int]: Pops [reg|int] arguments off the stack, performing a bit-xor operation, and storing the result in register a.\n```\n\nAll arithmetic operations have 4 variants; they may be suffixed with the character `'a'` (`adda`, `xora`), and they may take an additional register parameter, which is the destination register. Thus, using add as an example:\n```\nadd 5: Adds the top 5 values of the stack, storing the result in register a.\n\nadd 5, b: Adds the top 5 values of the stack, storing the result in register b instead.\n\nadda 5: Pushes the value of register A onto the stack, then adds the top 5 values of the stack, and stores the result in register a.\n\nadda 5, b: Pushes the value of register A onto the stack, adds the top 5 values of the stack, and stores the result in register b.\n```\n\nAll arithmetic instructions may also take a register as their first argument, to perform a variable number of operation, as follows:\n```\nmov 3, a: Stores the number 3 in register a.\nadd a: Adds the top a values of the stack (in this case 3), storing the result in register a.\n```\ndef __init__(self, cpu):\n\t\nUse Call-Based format\nANSWER:\n"}}