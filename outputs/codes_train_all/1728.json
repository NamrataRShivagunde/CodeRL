{"1728": {"code": ["\n\n\n\n\n\n\n\n\n\nUpdate method\n\nreturns:\n\n```python\n\nTask\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n```\n\n [8", "\n\n\n\nAction\n\n\n\n\n\n\n\n\n\n    n = 0 # n = 1\n    r = 1 # 1\n    A = 2\n    B = 6\n\n```\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n [direction]\n\n```\n\n", "\n\n\n\nUpdate method:\n\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n```\n\n    [0, 0, 0, 0]\n\n\n\n\n\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n [direction]\n\n```\n\n", "\n\n\n\n\n\n\n\n\n\n```\n\n    [2, 4, 6, 8]\n\n\n\n\n```\n\n\n    [2, 4, 6, 8]\n\n```\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n [4,", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdate:\n\n    [n] = key\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n```\n [direction]\n\n```", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    [n]\n    [n]\n\n```\n\n\n\n\n\n```python\n\n\n   \n\n```\n\n\n\n```\n\n\n\n\n```\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n```\n\n 1\n", "\n\n\n\n\n\nNote:\n\n\n\n\n\n\n\n\n\n\n    [2,4,6]\n\n```\n\n\n\n\n```\n\n\n\n\n\n\n```\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n [4,", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n    [1]\n    [2]\n    [1]\n\n```\n\n\n\n\n```\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n direction.Down if direction ==", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n    [n]\n\n    [n]\n\n```\n\n\n\n\n```\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\nThis is how you can behave the following:\n\n\n\n\n\n 1\n", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    [n] -> [n]\n\n```\n\n\n\n```\n\n\n\n    [n] -> [n]\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n```\n [direction]\n\n```", "\n\n\n\n\n\n\n\n\n\n\n\n\n    A, B, A, B, A, A, B, A, B, B\n\n```\n\n\n\n\n\n    [n]\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n```\n\n [4,", "\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\np(8) -> [8]\n\np(2) -> [8]\n\n```\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n4-A\n\n\n```\n\n\n\n\n\n\n [direction[0], direction[1", "\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\np(8) -> [8]\n\nr(4) -> [8]\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n [4", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n    [0]\n        [1]\n\n```\n\n\n\n\n```\n\n\n\n    [0]\n\n```\n\n\n\n\n\n []\n\n\n\n\n\n\n\n\n\n```\n\n\n\n```\n [direction.Up, Direction.Down", "\n\n\n\n\n\n\n\n\n\n\n\nUpdate\n\n\n\n\n    [n]\n\n    [n]\n\n    [n]\n\n```\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n [direction]\n\n```\n", "\n\n\n\n\nThis method can be used to update a tile.\n\n\n\nTask\n\n\nTask\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n```\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n```\n\n [4,", "\n\n\n\n\nUsage:\n\n\n\n\n\n\n\nUpdate\n\n\n\n\n\n\n\n```\n\n\n    [n] = [n]\n\n```\n\n\n\n\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n [direction[0], direction", "\n\n\n\n\n1) Press keys, 4, 6, 8\n\n2) Release keys\n\n3) Press keys\n\n4-6\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n [", "\n\n\n\n-------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n    [2]\n    [4]\n    [6]\n    \n\n\n\n\n```\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n [direction]\n\n", "\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdate:\n\n    [n] = current key\n\n    [n] = released key\n\n```\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n```\n\n##"], "prompt": "\nQUESTION:\nTask\n\nCreate a top-down movement system that would feel highly responsive to the player. In your Update method you have to check for the keys that are currently being pressed, the keys correspond to the enum Direction shown below, based on which key is pressed or released your method should behave this way:\n\n1) When a key is first pressed, the player has to change his direction to that of the current key, without moving\n\n2) If the key is still being pressed during the next Update, the player will move towards his current direction using these vectors: (Up = { 0, +1 } , Down = { 0, -1 }, Left = { -1, 0 }, Right = { +1, 0 })\n\n3) If a new key is pressed, it will gain precedence over the previous key and the player will act as per 1)\n\n4-A) If the current key (A) is released, then the precedence will go back to the previous key (B) (or the one before it, if (B) is not pressed anymore, and so on), then the player will behave as per 1).\n\n4-B) If the current key is released, and no other keys are being pressed, the player will stand still\n\n5) If all keys are released at once, the player will not move nor change direction\n\n6) If multiple keys are pressed at once, the order of precedence will be the following { Up, Down, Left, Right } \n\nExamples\n\n    (n = pressed key, [n] = current key, p() = press, r() = release, (8,2,4,6 = up, down, left, right)):\n\n    [] , p(8) -> [8] , p(4,6) -> 86[4] , r(6) -> 8[4] , r(4) -> [8] , r(8) -> []\n\n    [] , p(2486) -> 642[8] , r(2,8) -> 6[4] , r(4,6) -> []\n\nThis is what you'll need to use in your code (NB: the tile coordinates cannot be changed, you'll need to assign a new Tile each time the player moves):\n\n```python\nclass Tile:\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n            \n    def __str__(self):\n        return \"({},{})\".format(self._x, self._y)\n\nclass Input:\n\n    @staticmethod\n    def get_state(direction): # 2, 4, 6, 8\n        return Input.STATES[direction] # pressed = true, released = false\n```\ndef __init__(self, x, y):\n\t\nUse Call-Based format\nANSWER:\n"}}