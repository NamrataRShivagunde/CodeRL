{"1667": {"code": ["\n\n\n# Unflatten a list (Harder than easy)\n# Unflatten a list (Easy)\n# Unflatten a list (Easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list (Harder than easy): \n#\n\n\n\n\n\n.\n\n```\n\n", "\n\n\n\n\n# Unflatten a list (Easy)\n# Unflatten a list (Harder than easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n# To do things:\n# Todo:\n# To do more things!\n# is not available?\n#", "\n\n\n# Unflatten a list (Harder than easy):\n# Unflatten a list (Easy)\n# Unflatten a list (Easy)\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n# Recursion: \n\n# Unflatten a list (Easy!)\n. \n", "\n```\n\n\n\n\n\n# Flatten a list\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n in the new array.\n```\n\n# Flatten a list\n#\n[4, [5, 1, 7], 1]\n\n# Recursion\n#\n\n# The", "\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list/an array\n\n\n\n \n\n\n\n\n\n\n```\n\n\n\n# Refactor:\n# Unflatten a list/an array\n# Refactor: \n\n-\n\n```\n\n\n\n\n\n.\n# Refactor:\n# Un", "\n\n\n# Harder: Unflatten a list/an array. \n# Harder: Unflatten a list/an array. \n# Harder: Unflatten a list\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.\n\n\n```\n\n# As", "\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n```\n\n# All the two things you have to do: \n\n# The number of elements: \n\n# The number of remainder-value: \n\n# The number of remainder: \n\n\n\n\n\n\n\n\n\n\n\n``", "\n\n\n# Unflatten a list (Harder than easy)\n# Unflatten a list (Easy)\n# Unflatten a list (Easy)\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Add\n\n  1. The first number is 4.\n.", "\n\n\n# Flatten a list/an array: \n# Unflatten a list/an array: \n# Unflatten a list/an array: \n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.\n\n```\n\n# Recursion level:", "\n\n\n\n```\n\n\n\n\n\n\n\n\n\n1. All elements are added to the array.\n2. The next number is the sub-array.\n3. The next number is the sub-array.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.\n\n```\n\n#", "\n\n\n\n\n# Unflatten a list (Harder than easy)\n# Unflatten a list (Easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n# Unflatten a list (Harder than easy)\n# Unflatten a list\n\n\n\n\n\n\n\n\n.\n```\n", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Flatten a list of integers\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list/an array (Harder than easy)\n#\n [4, 5, 1, 7]\n#\n\n\n\n\n\n\n# The first run from left side", "\n\n\n\n\n\n\n\n\n\n\n# Convenience:\n#  Run a number of sub-arrays\n#  Run a number of sub-arrays\n# \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Now we have to unflatten\n#\n.\n# The next element is the sub-array.", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list\n\n# This is a little more complicated.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n# Just simple:\n# Flatten a list (Easy)\n# This is just a simple\n# The next run is 3.\n# The next run is.", "\n\n\n\n\n\n\n\n\n\n# Unflatten a list (Harder than easy):\n# Unflatten a list (Easy)\n\n# Unflatten a list (Easy)\n# Unflatten a list (Easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.\n\n# If we have to add", "\n\n\n\n\n# Flatten a list (Harder than easy):\n# Unflatten a list (Easy):\n# Unflatten a list (Easy)\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n# Unflatten a list (Harder than easy)", "\n```\n\n\n\n\n\n# Unflatten a list (Harder than easy)\n# Unflatten a list (Easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list (Harder than easy):\n# Unflatten a list (Easy)\n\n\n\n\n\n\n.\n``", "\n\n\n\n\n\n\n\n\n\n\n\n\n#\n\n\n\n\n\n\n# Unflatten a list/an array/an array/an array/an array/an array/an array\n\n# Quantifier:\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Unflatten a list/an array/an array\n\n\n\n\n```\n\n", "\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe method is called for the following:\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n## Examples\n\n# Unflatten a list/an array\n\n4 / 5 / 1\n\n\n\n\n\n\n\n\n\n\n```\n\n#", "\n\n\n\n\n# Unflatten a list (Easy):\n# Unflatten a list (Harder than easy)\n# Unflatten a list (Easy):\n# Unflatten a list (Easy)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n in the new array.\n\n```\n\n"], "prompt": "\nQUESTION:\n# Unflatten a list (Harder than easy)\n\nThis is the harder version of Unflatten a list (Easy)\n\nSo you have again to build a method, that creates new arrays, that can be flattened!\n\n# Shorter: You have to unflatten a list/an array.\n\nYou get an array of integers and have to unflatten it by these rules:\n```\n- You have to do several runs. The depth is the number of runs, you have to do.\n- In every run you have to switch the direction. First run from left, next run from right. Next left...\nEvery run has these rules:\n- You start at the first number (from the direction).\n- Take for every number x the remainder of the division by the number of still available elements (from \n  this position!) to have the number for the next decision.\n- If the remainder-value is smaller than 3, take this number x (NOT the remainder-Value) direct\n  for the new array and continue with the next number.\n- If the remainder-value (e.g. 3) is greater than 2, take the next remainder-value-number (e.g. 3)\n  elements/numbers (inclusive the number x, NOT the remainder-value) as a sub-array in the new array.\n  Continue with the next number/element AFTER this taken elements/numbers.\n- Every sub-array in the array is independent and is only one element for the progress on the array. \n  For every sub-array you have to follow the same rules for unflatten it.\n  The direction is always the same as the actual run.\n```\n\nSounds complicated? Yeah, thats why, this is the harder version...\nMaybe an example will help.\n\n```\n Array: [4, 5, 1, 7, 1] Depth: 2 -> [[ 4, [ 5, 1, 7 ] ], 1]\n \nSteps: \nFirst run: (start from left side!)\n1. The first number is 4. The number is smaller than the number of remaining elements, so it is the remainder-value (4 / 5 -> remainder 4).\n   So 4 numbers (4, 5, 1, 7) are added as sub-array in the new array.\n2. The next number is 1. It is smaller than 3, so the 1 is added direct to the new array.\nNow we have --> [[4, 5, 1, 7], 1]\n\nSecond run: (start from right side!)\n1. The last number (first from other side) is 1. So the 1 is added direct to the new array.\n2. The next element is the sub-array. So we use the rules for this.\n2a.The last number is 7. There are 4 elements in the array. So for the next decision you have to\n   take the remainder from 7 / 4 -> 3. So 3 numbers (5, 1, 7) are added as sub-array in the \n   new array.\n2b.Now there is the 4 and only one element last in this array. 4 / 1 -> remainder 0. It is smaller\n   than 3. So the 4 is added direct to the new array.\nNow we have --> [[ 4, [ 5, 1, 7 ] ], 1]\n```\n\nThe given array will always contain numbers. There will only be numbers > 0.\n\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have created other katas. Have a look if you like coding and challenges.\ndef unflatten(flat_array, depth):\n\t\nUse Call-Based format\nANSWER:\n"}}