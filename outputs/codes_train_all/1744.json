{"1744": {"code": ["\n\n\n\n\n\n\n\n\nfib(n) = 1\nb = 1\n\n```\n\nThe function is recursively defined recursively:\n\n1.    fib(n) = 1\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.\n\n\n2.\n\n\n    fib(1) = 1", "\n\n\n\n\n\n\n\n\n\n\n\nfib(n) = fib(n)\n\nfib(n) = fib(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = 1 * fib(n)\n\n\n```\n\n\n\nb = 2 * fib", "\n\n\nfib(n) = 1\nfib(n + 1) = 1\n```\n\n\n\n\n\n\n\n\n\n\n\nb = 1\nb = 2\nb = 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.    fib(n)\n```\n\n\n\n\n\n\n\n```\n\n3.", "\n\n\nfib(n) = 1\n\n```\n\n\n\n\n\n\n\n\n    fib(0) = 0\n    fib(1) = 1\n    fib(1) = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = 2 * fib(n)\n\n```\n\n\n\n\n   ", "\n\n\n\n\n\n\n\nfib(n) = 1\nb = 1\n\n```\n\n\n\n\n\n\n1.    fib(n) = fib(n)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n1.    fib(n) = 1\n```", "\n\n\n\n\n\n\n\n\n\n\n\n\n\nfib(n) = 1\n\n```\n\n\nfib(n) = 1\n```\n\n\nb = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n2.    fib(1) = 1\n```\n\n```\n\n", "\n\n\n\n\n\n\n\n\nfib(n) = 1\nfib(n) = 2\n\n```\n\n\n\n\n\n\n\n\nfib(n) = 2\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = fib(n)\n\nfib(n) = 1\n\n\n\n\n\n```", "\n\n\n\n\n\n\n\n\n\n0.    fib(0) = 1\n1.    fib(1) = 1\n2.    fib(1) = 1\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = fib(n)\nb = fib(n)\n\n\n```", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    fib(0) = 1\n    fib(1) = 1\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.    fib(2n) = 2 * fib(n)\n```\n\n\n\n`fib`", "\n\n\n\n\n\n\n\n\n\n    fib(0) = 1\n    fib(1) = 2\n    fib(1) = 2\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.    fib(n) = 1\n```\n\n\n\nb = 2 * (n", "\n\n\n\n\n\n```\n\nfib(n) = b * fib(n)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.    fib(n) = 1\n\n2.    fib(n) = 1\n```\n\n\n\n\n\n\n   ", "\n\n\n\n\n\n\n\nfib(1) = 2 * fib(n)\n\nfib(2) = 1 * fib(n + 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.    fib(n + 1) = 0\n```\n\n\n\n\n```\n\n", "\n\n\n\nfib(n) = fib(n)\n\n```\n\n\n\n\n\n\n\n\n\n\n\nb = fib(n)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.    fib(1) = 1\n\n2.    fib(1) = 1\n\n\n\n``", "\n\n\n\n\n\n\n\n\n\nfib(n) = fib(n)\n\n```\n\n\n\n\nfib(n) = fib(n)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfib(1) = fib(n)\nfib(n) = 0\n\n\n\n\n``", "\n\n\n\nfib(n) = 1\nfib(n + 1) = 1\nfib(n + 1) = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.    fib(n) = 1\n\n```\n\n\n\n\n\n```\n\n3.", "\n\n\n\n\n\n\n\nfib(n) = 1\nfib(n + 1) = 2\nfib(n + 1) = 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.    fib(n) = fib(n + 1)\n```\n\n\n\n\n\n```\n\n3.", "\n\n\nfib(n) = 1\nfib(n + 1) = 1\n\n\n\n\n\n\n\n\n\n\n\n\nfib(n) = 2 * fib(n) + 1 * fib(n + 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = fib(n + 1)\nb =", "\n\n\n\n\n\n\n\nfib(n) = fib(n) + fib(n) + fib(n + 1)\n\n\n\n\n\n\n\n\n\nfib(n) = fib(n)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n +\n\nb\n    +\n    2 *\n\n", "\n\n\n\n\n\n\n\nfib(1) = 1\nfib(2) = 1\n\n```\n\n\n\n\n\n\n\nfib(n) = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb = 1\n\nb + 2 = 1\nb + 2 = 1\n\n```\n\n\n\n\n\n``", "\n\n\n\n\n\n\n\n\nfib(n) = fib(n)\nfib(n) = fib(n)\n\n\nMethod:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.    fib(n) = 0\n\n```\n\n\n\n\n\n\n```"], "prompt": "\nQUESTION:\nThis Kata is a continuation of [Part 1](http://www.codewars.com/kata/the-fusc-function-part-1). The `fusc` function is defined recursively as follows:\n\n    fusc(0) = 0\n    fusc(1) = 1\n    fusc(2n) = fusc(n)\n    fusc(2n + 1) = fusc(n) + fusc(n + 1)\n    \nYour job is to produce the code for the `fusc` function. In this kata, your function will be tested with large values of `n` more than 1000 bits (in JS and PHP: at most 52 bits), so you should be concerned about stack overflow and timeouts.\n\nMethod suggestion:\n\nImagine that instead of `fusc(n)`, you were to implement `fib(n)`, which returns the n'th Fibonacci number.\n\nThe function is recursively defined by:\n\n```\n1.    fib(0) = 1\n2.    fib(1) = 1\n3.    fib(n + 2) = fib(n) + fib(n + 1), if n + 2 > 1\n```\nIf one translates the above definition directly into a recursive function, the result is not very efficient. One can try memoization, but that requires lots of space and is not necessary. So, first step is to try and find a _tail recursive_ definition. In order to do that we try to write both sides of equation 3) on the same form. Currently, the left side of the equation contains a single term, whereas the right side is the sum of two terms. A first attempt is to add `fib(n + 1)` to both sides of the equation:\n```\n3.    fib(n + 1) + fib(n + 2) = fib(n) + 2 * fib(n + 1)\n```\nThe two sides of the equation look much more alike, but there is still an essential difference, which is the coefficient of the second term of each side. On the left side of the equation, it is `1`  and, on the right, it is `2`. To remedy this, we can introduce a variable `b`:\n```\n3.    fib(n + 1) + b * fib(n + 2) = b * fib(n) + (b + 1) * fib(n + 1)\n```\nWe notice that the coefficients of the first term are not the same (`1` on the left and `b` on the right), so we introduce a variable `a`:\n```\n3.    a * fib(n + 1) + b * fib(n + 2) = b * fib(n) + (a + b) * fib(n + 1)\n```\nNow the two sides have the same form (call it `F`), which we can define as: \n\n```F(a, b, n) = a * fib(n) + b * fib(n + 1)```\n\nIn fact, we can write equation 3) as:\n```\n3.    F(a, b, n + 1) = F(b, a + b, n)\n```\nWe also have, by definition of `F` and `fib`:\n```\n4.    F(a, b, 0) = a * fib(0) + b * fib(1) = a + b\n```\nAlso, by definition of `F`: \n```\n5.    fib(n) = F(1, 0, n)\n```\n\nThe next step is to translate the above into code:\n```\ndef fib(n):\n\n    def F(a, b, n):\n        if n == 0: return a + b    # see 4. above\n        return F(b, a + b, n - 1)  # see 3. above\n\n    return F(1, 0, n)              # see 5. above\n```\n\nThe final step (optional for languages that support tail call optimization) is to replace the tail recursive function `F` with a loop:\n```\ndef fib(n):\n    a, b = 1, 0                    # see 5. above\n    while n > 0:\n        a, b, n = b, a + b, n - 1  # see 3. above\n    return a + b .                 # see 4. above\n```\nVoila! Now, go do the same with `fusc`.\ndef fusc(n):\n\t\nUse Call-Based format\nANSWER:\n"}}